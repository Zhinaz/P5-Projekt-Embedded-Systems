\section{Future works} \label{sec:future_works}
This sections presents some of the ideas for future extensions, that could be developed and implemented to make the \projname{} better at collecting objects. 

\subsubsection{Improved object detection}
Having a more precise distance sensor to detect objects would greatly increase the precision while the \projname{} is scanning. Other options could be lasers or cameras.

\subsubsection{Coloured object detection}
Having a colour sensor next to the object detector would allow the robot to determine between object that should be picked up and object that it should ignore. When collecting objects in for example a child's room, there are several objects that the robot should not try to collect such as legs on a table or bed. The robot could be programmed to avoid the colours of these legs. The problem here is that there exist an almost unlimited amount of differently colour table legs, therefore an easier solution would have to be applied. This could for example be to apply a plain-coloured slap bracelet, to each leg with a colour that the robot should ignore \citep{slap_bracelet}.

\subsubsection{Expanded area algorithm}
As it is right now the robot is only able to detect objects that are approximately 50 cm away from it while doing the 360 degrees scan. In a larger room or area this would be far from enough and the robot should therefore be able to more to a new area that has yet to be scanned.

This could be done by driving approximately 100 cm in a chosen direction and do a new search. The problem with this is that the robot might hit an object on the way to the new scanning point. There would also be corners between the circles that the ultrasonic would not have scanned due to the distance.

Another solution would be to drive to the edge of the scanned area and do a new scan from here. This would ensure that no object would be hit while driving to the new area. The problem is that the robot would still do a 360 degrees scan even though that half of the area would already have been scanned. 

A more intelligent solution could be to map the area, while scanning and collecting objects. This would ensure that every position, inside the boundary would be visited, ensuring that all objects inside the boundary are collected. 

\subsubsection{Object deposit area}
While the robot is able to store some objects while driving around, having a deposit area would allow the robot to pick up more objects in a larger area. This would require an exact coordinate system that the robot should be able to follow. This is something that is not implemented in the project, but it was discussed in the early stages as a solution. Being able to find this deposit area and getting back is the primary problem for the robot in its current state. The solution to this would be to place the deposit area at the robots start position, but this would result in a new problem if the robot ever has to do a new 360 degree search. 

\subsubsection{Environment Detection and Colour Calibration}
When detecting the boundaries of the environment, the robot currently checks the floor for any changes in colour. If the robot was to be truly useful in as a non-prototype robot, it would most likely have to detect walls instead of colour on the floor. Both could be useful in different circumstances.

In the finished product, the robot uses hard-coded colour values to check against the input of the colour sensors.. Since black tape was used as a boundary for all tests, it will only be able to detect boundaries of the colour black. To make the robot more dynamic, code was written to allow calibration of the colour sensors: when starting the robot, it would be placed with the sensors above the boundary, and a button would be pressed to calibrate that colour. The same procedure would be repeated for the floor. With two colour variables stored, the robot would be able to calculate an average colour between the two, and ask whether or not the input colour currently seen is more likely to be the boundary or the floor. This code, however, was not implemented in the final product, due to time constraints.