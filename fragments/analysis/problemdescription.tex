\section{Problem description} \label{sec:problem-description}

The problem that the \projname{}-prototype has to solve, is to collect a number of objects within a given environment. It has to do this by driving to and collecting every object, after they have been located. The issue of locating the objects is complex, and the question of how the robot can ensure that all objects in the environment has been found, is hard to answer. To do this, one would have to be able to confirm, whether or not all possible locations have been checked. \fxnote{nævn dette problem senere. hvad ender vi med at gøre? dvs. ignorere problemet og sige "find \# objekter"}

Once all objects have been found, the problem is to find a path between all the objects, that the robot can then follow in order to pick them up. This path is known as a hamiltonian path; it must visit all locations exactly once. The problem, however, is not finding a path, since many such paths exist -- rather, the problem is to find an acceptable route that preferably is as close to the optimal path as possible.

The optimal path between the objects would be the path that is most efficient. Multiple variables affect the efficiency, for instance power used, computations required or distance travelled. However in this project, the focus will be to reduce the time spent from start to completion. In a real scenario, you would want the \projname{} to be reasonably fast at cleaning up an area, or at completing any other given task, so it makes sense to use it instead of doing the task yourself.

To achieve a faster completion time, reducing distance travelled to a reasonable level compared to the shortest possible path, will be the focus of this report. This problem is known as the \emph{travelling salesman problem}, and is NP-hard \citep{tsp}. To find the shortest route, one would have to calculate the distance of every possible route between the objects, which has a calculation complexity of $\mathcal{O}(n!)$. This is obviously not feasible, and thus heuristics will be used in following chapters to develop algorithms that can solve the problem within an acceptable time limit.


